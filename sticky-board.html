<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Your Local Sticky Board</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* Matching light blue-gray for clean look */
            min-height: 100vh;
            overflow: hidden; 
            cursor: pointer; /* Indicates where the user can click to create a note */
        }
        
        /* Base style for both Notes and Image Pins */
        .artifact {
            box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.3);
            position: absolute; 
            cursor: grab;
            user-select: none;
            transition: box-shadow 0.1s;
            border-radius: 0.5rem; /* rounded-lg */
        }

        .note {
            /* Existing note styles */
            min-width: 220px; 
            min-height: 200px;
            padding: 5px; 
            display: flex;
            flex-direction: column; 
            background-color: #fef08a; /* Default color for text notes */
        }

        .image-pin {
            /* New style for image pins */
            min-width: 100px;
            min-height: 100px;
            border: 4px solid #3b82f6; /* Blue border for visibility */
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #cbd5e1; /* Slate-300 background for images */
        }
        
        .image-pin img {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Ensures the image fits within the bounds without cropping */
        }

        .artifact:active {
            box-shadow: 8px 8px 20px rgba(0, 0, 0, 0.4);
            transform: rotate(1deg); 
            cursor: grabbing;
        }

        .note-content-area {
            flex-grow: 1; 
            padding: 15px 5px 5px 5px; 
            display: flex;
            flex-direction: column;
        }
        .note textarea {
            flex-grow: 1; 
            resize: none;
            border: none;
            background: transparent;
            width: 100%;
            height: 100%;
            padding: 0;
            outline: none;
            color: #374151; 
            cursor: text;
            line-height: 1.4;
            user-select: text !important; 
        }
        .note-container {
            position: relative;
        }
        
        /* Shared Delete Button Style */
        .delete-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 24px; /* Slightly larger for easier tap */
            height: 24px;
            background-color: rgba(255, 255, 255, 0.7); 
            color: #ef4444; 
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.85rem;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
            opacity: 0.8;
            transition: opacity 0.15s, background-color 0.15s;
            z-index: 100; /* Ensure it's above everything */
            border: 1px solid #ef4444;
        }
        .delete-btn:hover {
            opacity: 1;
            background-color: #f87171; 
            color: white;
        }

        .header {
            z-index: 50; 
            position: sticky;
            top: 0;
        }

        /* Shared Resizing Handle Styles */
        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 20px; /* Slightly larger handle */
            height: 20px;
            cursor: nwse-resize;
            z-index: 110; /* Above the delete button */
            border-bottom: 20px solid rgba(0, 0, 0, 0.25);
            border-left: 20px solid transparent;
            border-radius: 0 0 0.5rem 0;
            opacity: 0.8;
            transition: opacity 0.15s;
        }
        .resize-handle:hover {
            opacity: 1;
        }

        /* Toolbar Styling (only for notes) */
        .toolbar {
            border-top: 1px solid rgba(209, 213, 219, 0.5); 
            padding-top: 5px;
            padding-bottom: 2px;
            margin-top: 5px; 
        }
        .toolbar-btn {
            padding: 2px 5px;
            margin: 0 2px;
            border-radius: 4px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.1s;
        }
        .toolbar-btn:hover {
            background-color: rgba(0, 0, 0, 0.1);
        }
        .toolbar-btn.active {
            background-color: rgba(0, 0, 0, 0.2);
            font-weight: 700;
        }
        .color-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.1s;
        }
        .color-dot.active {
            border-color: #374151;
        }
    </style>
</head>
<body id="stickyBoard" class="p-0">

    <!-- Header and Info Box -->
    <header class="header bg-transparent py-6 px-6 mb-4 text-center relative">
        <!-- Save Status Indicator -->
        <div id="save-status" class="absolute top-6 right-6 text-xs font-medium text-gray-400 italic transition-colors duration-300">
            Loading...
        </div>

        <!-- Title Change: Added flex and moved SVG icon here, increased size to w-8 h-8 -->
        <h1 class="text-4xl font-extrabold text-gray-800 mb-2 flex items-center justify-center">
            <svg class="w-8 h-8 mr-3 text-indigo-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg>
            Your Local Sticky Board
        </h1>
        <!-- Instructions Updated with hard-coded styling for emphasis -->
        <p class="text-lg text-gray-600">
            Click the background to create a text note. 
            <span class="font-extrabold text-red-500">Press Ctrl+V (or Cmd+V) to paste an image.</span> 
            <span class="font-extrabold text-indigo-500">Drag to move, corner to resize.</span>
        </p>
    </header>

    <!-- Main Note Container -->
    <div id="notesContainer" class="note-container w-full h-full absolute top-0 left-0">
        <!-- Sticky notes and Image Pins will be appended here -->
    </div>
    
    <!-- Custom Modal for Notifications (instead of alert()) -->
    <div id="notificationModal" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 z-[9999] flex justify-center items-center">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full">
            <h3 class="text-lg font-bold mb-3 text-gray-800">Notification</h3>
            <p id="notificationText" class="text-gray-600 mb-4">Message goes here.</p>
            <button onclick="document.getElementById('notificationModal').classList.add('hidden')" class="w-full bg-indigo-500 text-white py-2 rounded-md hover:bg-indigo-600 transition duration-150">Got It</button>
        </div>
    </div>


    <script>
        // Global State & Constants
        let highestZIndex = 1;
        let isDragging = false;
        let isResizing = false; // This is a global flag, used to prevent creating notes while moving/resizing
        let dragTimer = 0; 
        
        // In-memory store: {id: {type, content (text or image dataURL), x, y, z, ...}}
        let notes = {}; 
        
        const MIN_SIZE_NOTE = 220; 
        const MIN_SIZE_IMAGE = 100;

        const COLORS = [
            { name: 'yellow', class: 'bg-yellow-200' }, // #fef08a
            { name: 'blue', class: 'bg-blue-200' },    // #bfdbfe
            { name: 'green', class: 'bg-green-200' },   // #d9f99d
            { name: 'pink', class: 'bg-pink-200' }     // #fecdd3
        ];
        
        const FONT_SIZES = [
            { label: 'S', value: 'sm', class: 'text-sm' },
            { label: 'M', value: 'md', class: 'text-base' },
            { label: 'L', value: 'lg', class: 'text-lg' }
        ];

        const DEFAULT_NOTE_PROPS = {
            type: 'text', // New property to distinguish between text and image
            content: '',
            x: 50,
            y: 100,
            z: 1,
            width: MIN_SIZE_NOTE,
            height: MIN_SIZE_NOTE,
            color: 'yellow',
            fontSize: 'md', 
            fontWeight: 'normal',
            fontStyle: 'normal'
        };
        
        const DEFAULT_IMAGE_PROPS = {
            type: 'image',
            content: '', // This will hold the Data URL of the image
            x: 50,
            y: 100,
            z: 1,
            width: 300,
            height: 200,
        };

        /**
         * Shows a custom notification modal.
         */
        function showNotification(message) {
            document.getElementById('notificationText').textContent = message;
            document.getElementById('notificationModal').classList.remove('hidden');
        }

        /**
         * Generates a unique ID.
         */
        function generateUniqueId() {
            return 'note-' + crypto.randomUUID();
        }

        // --- INDEXED DB FUNCTIONS (Robust Storage) ---
        
        const DB_NAME = 'StickyBoardDB';
        const DB_VERSION = 1;
        const STORE_NAME = 'notes';

        let db;

        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = (event) => {
                    console.error("Database error: " + event.target.errorCode);
                    updateSaveStatus("Storage Error", true);
                    reject(event.target.error);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME, { keyPath: "id" });
                    }
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    resolve(db);
                };
            });
        }

        function updateSaveStatus(text, isError = false) {
            const el = document.getElementById('save-status');
            el.textContent = text;
            if (isError) {
                el.classList.remove('text-gray-400', 'text-green-500');
                el.classList.add('text-red-500');
            } else {
                el.classList.remove('text-gray-400', 'text-red-500');
                el.classList.add('text-green-500');
                // Fade out back to gray after a while
                setTimeout(() => {
                    el.classList.remove('text-green-500');
                    el.classList.add('text-gray-400');
                }, 2000);
            }
        }

        /**
         * Saves a single artifact to IndexedDB.
         */
        async function saveArtifactToDB(data) {
            if (!db) await initDB();
            updateSaveStatus("Saving...");
            
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], "readwrite");
                const store = transaction.objectStore(STORE_NAME);
                // Ensure ID is present in data for keyPath
                const request = store.put(data);

                request.onsuccess = () => {
                    updateSaveStatus("Saved");
                    resolve();
                };

                request.onerror = (event) => {
                    console.error("Error saving note:", event.target.error);
                    updateSaveStatus("Save Failed", true);
                    reject(event.target.error);
                };
            });
        }

        /**
         * Deletes an artifact from IndexedDB.
         */
        async function deleteArtifactFromDB(id) {
            if (!db) await initDB();
            updateSaveStatus("Saving...");

            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], "readwrite");
                const store = transaction.objectStore(STORE_NAME);
                const request = store.delete(id);

                request.onsuccess = () => {
                    updateSaveStatus("Saved");
                    resolve();
                };

                request.onerror = (event) => {
                    console.error("Error deleting note:", event.target.error);
                    reject(event.target.error);
                };
            });
        }

        /**
         * Loads all notes from IndexedDB.
         */
        async function loadNotesFromDB() {
            if (!db) await initDB();

            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], "readonly");
                const store = transaction.objectStore(STORE_NAME);
                const request = store.getAll();

                request.onsuccess = (event) => {
                    const result = event.target.result;
                    // Convert array back to object map
                    const notesMap = {};
                    result.forEach(note => {
                        notesMap[note.id] = note;
                    });
                    resolve(notesMap);
                };

                request.onerror = (event) => {
                    reject(event.target.error);
                };
            });
        }

        /**
         * Migration logic to move data from old localStorage to IndexedDB.
         */
        function migrateFromLocalStorage() {
            const storedJSON = localStorage.getItem('stickyNotesData');
            if (storedJSON) {
                try {
                    const oldNotes = JSON.parse(storedJSON);
                    // Migrate each note to DB
                    Object.entries(oldNotes).forEach(([id, data]) => {
                        // Ensure data has the ID property for the keyPath
                        data.id = id;
                        saveArtifactToDB(data);
                    });
                    // Optional: Clear old storage to avoid double loading later
                    // localStorage.removeItem('stickyNotesData'); 
                    return oldNotes;
                } catch (e) {
                    console.error("Migration failed", e);
                }
            }
            return null;
        }

        /**
         * Main load function.
         */
        async function loadNotes() {
            try {
                await initDB();
                let loadedNotes = await loadNotesFromDB();
                
                // If DB is empty, try migrating from localStorage
                if (Object.keys(loadedNotes).length === 0) {
                    const migrated = migrateFromLocalStorage();
                    if (migrated) {
                        loadedNotes = migrated;
                    }
                }

                notes = loadedNotes;

                // Process notes for rendering
                Object.values(notes).forEach(note => {
                    // Ensure compatibility with old notes and new properties
                    if (note.type === 'text') {
                            Object.keys(DEFAULT_NOTE_PROPS).forEach(key => {
                            if (note[key] === undefined) {
                                note[key] = DEFAULT_NOTE_PROPS[key];
                            }
                        });
                    } else if (note.type === 'image') {
                        Object.keys(DEFAULT_IMAGE_PROPS).forEach(key => {
                            if (note[key] === undefined) {
                                note[key] = DEFAULT_IMAGE_PROPS[key];
                            }
                        });
                    } else {
                        // If type is missing (legacy notes), default to 'text'
                            note.type = 'text';
                            Object.keys(DEFAULT_NOTE_PROPS).forEach(key => {
                            if (note[key] === undefined) {
                                note[key] = DEFAULT_NOTE_PROPS[key];
                            }
                        });
                    }

                    if (note.z > highestZIndex) {
                        highestZIndex = note.z;
                    }
                });
                
                renderNotes();
                updateSaveStatus("Loaded");

            } catch (e) {
                console.error("Error loading notes:", e);
                updateSaveStatus("Error Loading", true);
            }

            document.getElementById('stickyBoard').addEventListener('click', handleBoardClick);
            document.addEventListener('paste', handlePaste);
        }
        
        /**
         * Renders all notes/artifacts from the 'notes' object to the DOM.
         */
        function renderNotes() {
            const container = document.getElementById('notesContainer');
            container.innerHTML = ''; 
            
            // Sort by Z-index before rendering to ensure correct stacking order
            const sortedNotes = Object.entries(notes).sort(([, a], [, b]) => a.z - b.z);
            
            sortedNotes.forEach(([id, data]) => {
                if (data.type === 'text') {
                    const el = createNoteElement(id, data.content, data.x, data.y, data.z, data.width, data.height);
                    container.appendChild(el);
                } else if (data.type === 'image') {
                    const el = createImagePinElement(id, data.content, data.x, data.y, data.z, data.width, data.height);
                    container.appendChild(el);
                }
            });
        }

        // --- LOCAL CRUD OPERATIONS ---
        
        /**
         * Updates the in-memory artifact object and saves to DB.
         */
        function saveArtifact(id, data) {
            if (!notes[id]) {
                // If ID is new, determine default props based on type
                if (data.type === 'image') {
                    notes[id] = { ...DEFAULT_IMAGE_PROPS, z: highestZIndex };
                } else {
                    notes[id] = { ...DEFAULT_NOTE_PROPS, z: highestZIndex };
                }
            }
            
            // Merge updates
            notes[id] = { ...notes[id], ...data, id: id }; // Ensure ID is set in object
            
            // Save to IndexedDB
            saveArtifactToDB(notes[id]);
        }

        /**
         * Deletes a sticky note or image pin from the in-memory object and DB.
         */
        function deleteArtifact(id) {
            delete notes[id];
            deleteArtifactFromDB(id);
            
            const artifactEl = document.getElementById(id);
            if (artifactEl) {
                artifactEl.remove();
            }
        }


        // --- STICKY NOTE (TEXT) FUNCTIONS ---

        /**
         * Applies styling based on the note data object.
         */
        function applyNoteStyles(noteEl, data) {
            const currentNote = notes[noteEl.id];
            if (!currentNote || currentNote.type !== 'text') return;

            // 1. Color
            const colorClass = COLORS.find(c => c.name === data.color)?.class || COLORS[0].class;
            // Remove all existing color classes and apply the new one
            noteEl.classList.remove(...COLORS.map(c => c.class));
            noteEl.classList.add(colorClass);

            // 2. Font Styles (Applied to textarea)
            const textarea = noteEl.querySelector('textarea');
            if (textarea) {
                // Clear existing font style classes (Bold, Italic, and all Sizes)
                textarea.classList.remove('font-bold', 'italic', 'font-normal', 'not-italic');
                textarea.classList.remove(...FONT_SIZES.map(s => s.class));

                // Apply new styles
                textarea.classList.add(data.fontWeight === 'bold' ? 'font-bold' : 'font-normal');
                textarea.classList.add(data.fontStyle === 'italic' ? 'italic' : 'not-italic');
                
                // Find and apply the correct font size class
                const fontSizeClass = FONT_SIZES.find(s => s.value === data.fontSize)?.class || FONT_SIZES[1].class;
                textarea.classList.add(fontSizeClass);
            }

            // 3. Toolbar Active States (Applied to controls)
            const toolbar = noteEl.querySelector('.toolbar');
            if (toolbar) {
                // Color dots
                toolbar.querySelectorAll('.color-dot').forEach(dot => {
                    dot.classList.remove('active');
                    if (dot.getAttribute('data-color') === data.color) {
                        dot.classList.add('active');
                    }
                });

                // Font Size buttons
                toolbar.querySelectorAll('.size-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.getAttribute('data-size') === data.fontSize) {
                        btn.classList.add('active');
                    }
                });

                // Bold/Italic buttons
                toolbar.querySelector('[data-style="bold"]').classList.toggle('active', data.fontWeight === 'bold');
                toolbar.querySelector('[data-style="italic"]').classList.toggle('active', data.fontStyle === 'italic');
            }
        }

        /**
         * Creates the configuration toolbar for a sticky note.
         */
        function createToolbar(noteId) {
            const toolbar = document.createElement('div');
            toolbar.className = 'toolbar flex items-center justify-between p-1 mt-1'; 

            // --- 1. Color Selection ---
            const colorGroup = document.createElement('div');
            colorGroup.className = 'flex space-x-1';
            
            COLORS.forEach(color => {
                const dot = document.createElement('div');
                dot.className = `color-dot ${color.class}`;
                dot.setAttribute('data-color', color.name);
                dot.title = `Change color to ${color.name}`;

                dot.addEventListener('click', (e) => {
                    e.stopPropagation();
                    saveArtifact(noteId, { color: color.name });
                    applyNoteStyles(document.getElementById(noteId), notes[noteId]);
                });
                colorGroup.appendChild(dot);
            });
            toolbar.appendChild(colorGroup);


            // --- 2. Font Style and Size Controls ---
            const styleGroup = document.createElement('div');
            styleGroup.className = 'flex items-center space-x-1 text-xs text-gray-700';

            // Bold Button
            const boldBtn = document.createElement('span');
            boldBtn.className = 'toolbar-btn font-extrabold select-none';
            boldBtn.textContent = 'B';
            boldBtn.setAttribute('data-style', 'bold');
            boldBtn.title = 'Toggle Bold';

            boldBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const currentWeight = notes[noteId].fontWeight;
                const newWeight = currentWeight === 'bold' ? 'normal' : 'bold';
                saveArtifact(noteId, { fontWeight: newWeight });
                applyNoteStyles(document.getElementById(noteId), notes[noteId]);
            });

            // Italic Button
            const italicBtn = document.createElement('span');
            italicBtn.className = 'toolbar-btn italic select-none';
            italicBtn.textContent = 'I';
            italicBtn.setAttribute('data-style', 'italic');
            italicBtn.title = 'Toggle Italic';
            
            italicBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const currentStyle = notes[noteId].fontStyle;
                const newStyle = currentStyle === 'italic' ? 'normal' : 'italic';
                saveArtifact(noteId, { fontStyle: newStyle });
                applyNoteStyles(document.getElementById(noteId), notes[noteId]);
            });
            
            styleGroup.appendChild(boldBtn);
            styleGroup.appendChild(italicBtn);
            
            // Font Size Buttons
            FONT_SIZES.forEach(size => {
                const sizeBtn = document.createElement('span');
                sizeBtn.className = `toolbar-btn size-btn select-none`; 
                sizeBtn.textContent = size.label;
                sizeBtn.setAttribute('data-size', size.value);
                sizeBtn.title = `Font Size ${size.label}`;

                sizeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    saveArtifact(noteId, { fontSize: size.value });
                    applyNoteStyles(document.getElementById(noteId), notes[noteId]);
                });
                styleGroup.appendChild(sizeBtn);
            });

            toolbar.appendChild(styleGroup);

            return toolbar;
        }

        /**
         * Creates a draggable and resizable sticky note element (TEXT).
         */
        function createNoteElement(id, content, x, y, z, width, height) {
            const note = document.createElement('div');
            note.id = id; 
            note.className = 'artifact note rounded-lg shadow-lg hover:shadow-xl transition-shadow ' + COLORS.find(c => c.name === notes[id].color)?.class;
            note.setAttribute('data-id', id);
            note.setAttribute('data-type', 'text');
            note.style.left = `${x}px`;
            note.style.top = `${y}px`;
            note.style.zIndex = z;
            note.style.width = `${width}px`;
            note.style.height = `${height}px`;

            highestZIndex = Math.max(highestZIndex, z);

            // 1. Content Area
            const contentArea = document.createElement('div');
            contentArea.className = 'note-content-area';
            note.appendChild(contentArea);
            
            // 2. Textarea
            const textarea = document.createElement('textarea');
            textarea.value = content;
            textarea.placeholder = 'Write your thoughts...';
            textarea.maxLength = 1000; 
            contentArea.appendChild(textarea);
            
            // 3. Toolbar
            const toolbar = createToolbar(id);
            note.appendChild(toolbar); 


            // Textarea input listener (saves content on change)
            textarea.addEventListener('input', (e) => {
                e.stopPropagation();
                clearTimeout(textarea.saveTimeout);
                textarea.saveTimeout = setTimeout(() => {
                    saveArtifact(id, { content: textarea.value });
                }, 500);
            });

            // Focus listener (brings note to front)
            textarea.addEventListener('focus', (e) => {
                e.stopPropagation(); 
                bringToFront(note);
            });


            // 4. Delete Button, 5. Resize Handle, and Drag Logic
            setupArtifactInteraction(note, id, MIN_SIZE_NOTE);

            // Apply styles based on loaded data
            applyNoteStyles(note, notes[id]);

            return note;
        }

        // --- IMAGE PIN FUNCTIONS ---

        /**
         * Creates a draggable and resizable Image Pin element.
         */
        function createImagePinElement(id, dataUrl, x, y, z, width, height) {
            const pin = document.createElement('div');
            pin.id = id;
            pin.className = 'artifact image-pin shadow-lg hover:shadow-xl transition-shadow';
            pin.setAttribute('data-id', id);
            pin.setAttribute('data-type', 'image');
            pin.style.left = `${x}px`;
            pin.style.top = `${y}px`;
            pin.style.zIndex = z;
            pin.style.width = `${width}px`;
            pin.style.height = `${height}px`;

            highestZIndex = Math.max(highestZIndex, z);

            // Image element
            const img = document.createElement('img');
            img.src = dataUrl;
            img.alt = 'Pasted Image';
            pin.appendChild(img);

            // Setup interaction (Delete, Resize, Drag)
            setupArtifactInteraction(pin, id, MIN_SIZE_IMAGE);

            return pin;
        }


        // --- PASTE LISTENER FOR IMAGES ---

        function handlePaste(event) {
            // Check if the paste event is happening inside a text area (where we want text)
            if (event.target.tagName === 'TEXTAREA') {
                return; 
            }
            
            const items = (event.clipboardData || event.originalEvent.clipboardData).items;
            let imageFound = false;

            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf("image") !== -1) {
                    const blob = items[i].getAsFile();
                    if (blob) {
                        event.preventDefault(); // Prevent default paste action if we handle an image
                        imageFound = true;
                        
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const dataUrl = e.target.result;
                            
                            highestZIndex++;
                            const newId = generateUniqueId();
                            
                            // Determine creation position (center of viewport or current mouse position if available)
                            const x = event.clientX ? event.clientX - (DEFAULT_IMAGE_PROPS.width / 2) : 50;
                            const y = event.clientY ? event.clientY - (DEFAULT_IMAGE_PROPS.height / 2) : 100;

                            const newPinData = {
                                ...DEFAULT_IMAGE_PROPS,
                                content: dataUrl,
                                x: x,
                                y: y,
                                z: highestZIndex,
                            };
                            
                            saveArtifact(newId, newPinData);
                            // Rerender all notes to update Z-index display and ensure new element is appended
                            renderNotes();
                            
                            // Notification removed here as requested
                        };
                        reader.readAsDataURL(blob);
                        return; // Process one image and stop
                    }
                }
            }

            if (!imageFound) {
                 // If text was pasted outside of a textarea, just ignore it silently
            }
        }


        // --- COMMON INTERACTION LOGIC (DRAG, RESIZE, DELETE, Z-INDEX) ---

        /**
         * Increases the Z-index of the given artifact element and saves it locally.
         */
        function bringToFront(artifactEl) {
            highestZIndex++;
            artifactEl.style.zIndex = highestZIndex;
            const artifactId = artifactEl.getAttribute('data-id');
            saveArtifact(artifactId, { z: highestZIndex });
        }

        /**
         * Sets up common interaction handlers (Drag, Resize, Delete) for both notes and image pins.
         */
        function setupArtifactInteraction(artifact, id, minSize) {
            
            // 1. Delete Button
            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'delete-btn';
            deleteBtn.textContent = 'X';
            deleteBtn.title = `Delete ${artifact.getAttribute('data-type') === 'image' ? 'Image Pin' : 'Note'}`;
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation(); 
                deleteArtifact(id);
            });
            artifact.appendChild(deleteBtn);

            // 2. Copy Button (for Image Pins only)
            if (artifact.getAttribute('data-type') === 'image') {
                const copyBtn = document.createElement('div');
                copyBtn.className = 'delete-btn'; // Reuse delete-btn style class
                // Override positioning and style for Copy
                copyBtn.style.right = '35px'; // Move to the left of the delete button
                copyBtn.style.color = '#3b82f6'; // Blue text
                copyBtn.style.borderColor = '#3b82f6'; // Blue border
                copyBtn.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
                copyBtn.textContent = '⿻';
                copyBtn.title = 'Copy Image';
                
                copyBtn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const img = artifact.querySelector('img');
                    if (!img || !img.src) return;

                    // Try standard API first (might work in some contexts, good to keep if permissions change)
                    try {
                        const res = await fetch(img.src);
                        const blob = await res.blob();
                        await navigator.clipboard.write([
                            new ClipboardItem({ [blob.type]: blob })
                        ]);
                        showNotification('Image copied to clipboard!', 'success');
                        return;
                    } catch (err) {
                        console.warn('Clipboard API failed, trying fallback...', err);
                    }

                    // Fallback: execCommand with RENDERED Element
                    // To support Paint in restricted environments, we attempt to place 
                    // a virtually visible (but transparent) element on screen.
                    try {
                        const tempDiv = document.createElement('div');
                        tempDiv.contentEditable = true;
                        
                        // CRITICAL FIX: Make it "visible" to the browser's layout engine, just transparent.
                        tempDiv.style.position = 'fixed';
                        tempDiv.style.left = '0';
                        tempDiv.style.top = '0';
                        tempDiv.style.opacity = '0.01'; // Nearly invisible
                        tempDiv.style.zIndex = '-1';
                        tempDiv.style.pointerEvents = 'none';
                        
                        document.body.appendChild(tempDiv);

                        const imgClone = document.createElement('img');
                        imgClone.src = img.src;
                        // Ensure image has size to be rendered
                        imgClone.style.maxWidth = '500px'; 
                        tempDiv.appendChild(imgClone);

                        // Wait a micro-tick to ensure render? Usually synchronous for layout, 
                        // but safety first for some browsers.
                        
                        const selection = window.getSelection();
                        const range = document.createRange();
                        range.selectNode(imgClone);
                        selection.removeAllRanges();
                        selection.addRange(range);
                        
                        const successful = document.execCommand('copy');
                        
                        // Cleanup
                        selection.removeAllRanges();
                        document.body.removeChild(tempDiv);

                        if (successful) {
                            // Success
                        } else {
                            throw new Error('execCommand returned false');
                        }
                    } catch (err) {
                        console.error('Copy failed:', err);
                    }
                });
                artifact.appendChild(copyBtn);
            }
            
            // 3. Resizing Handle
            const resizeHandle = document.createElement('div');
            resizeHandle.className = 'resize-handle';
            artifact.appendChild(resizeHandle);
            
            // --- RESIZING LOGIC ---
            let initialMouseX, initialMouseY, initialWidth, initialHeight;
            let currentWidth, currentHeight;
            let isLocalResizing = false; // New local flag for this specific artifact's resizing state

            const resizeStart = (e) => {
                e.stopPropagation();
                e.preventDefault(); 

                isLocalResizing = true;
                isResizing = true; // Set global flag to prevent note creation
                bringToFront(artifact);

                // FIX: Use ternary operator to safely get coordinates
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                initialMouseX = clientX;
                initialMouseY = clientY;
                
                initialWidth = artifact.offsetWidth;
                initialHeight = artifact.offsetHeight;
                
                // Attach global listeners for move and end events ONLY when starting a resize
                document.addEventListener('mousemove', resize);
                document.addEventListener('mouseup', resizeEnd);
                document.addEventListener('touchmove', resize);
                document.addEventListener('touchend', resizeEnd);
            }

            const resize = (e) => {
                if (!isLocalResizing) return;
                e.preventDefault(); 

                // FIX: Use ternary operator to safely get coordinates
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                const dx = clientX - initialMouseX;
                const dy = clientY - initialMouseY;

                // Apply difference, ensuring minimum size
                currentWidth = Math.max(minSize, initialWidth + dx);
                currentHeight = Math.max(minSize, initialHeight + dy);

                artifact.style.width = `${currentWidth}px`;
                artifact.style.height = `${currentHeight}px`;
            }

            const resizeEnd = () => {
                if (!isLocalResizing) return;

                isLocalResizing = false;
                isResizing = false; // Reset global flag
                
                if (currentWidth && currentHeight) {
                    saveArtifact(id, { width: currentWidth, height: currentHeight });
                }
                currentWidth = undefined;
                currentHeight = undefined;
                
                // Detach global listeners immediately after resize ends
                document.removeEventListener('mousemove', resize);
                document.removeEventListener('mouseup', resizeEnd);
                document.removeEventListener('touchmove', resize);
                document.removeEventListener('touchend', resizeEnd);
            }
            
            // Attach mouse and touch start events for resizing
            resizeHandle.addEventListener('mousedown', resizeStart);
            resizeHandle.addEventListener('touchstart', resizeStart);
            
            // --- DRAGGING LOGIC ---

            let isLocalDragging = false;
            let currentX, currentY, initialX, initialY, xOffset = artifact.offsetLeft, yOffset = artifact.offsetTop, artifactMoved = false;
            
            const dragStart = (e) => {
                // If currently resizing, don't start dragging
                if (isResizing) return; 
                e.stopPropagation();

                // If the target is the textarea or toolbar, prevent drag logic for notes
                if (artifact.getAttribute('data-type') === 'text' && (e.target.closest('.toolbar') || e.target.tagName === 'TEXTAREA')) {
                    return;
                }
                
                // Allow dragging on the artifact itself, but ignore clicks on delete/resize handles
                // Also ensure we don't start dragging if the copy button was clicked
                if (e.target.classList.contains('delete-btn') || e.target.classList.contains('resize-handle') || e.target.textContent === '⿻') {
                    return;
                }

                e.preventDefault(); 
                
                isLocalDragging = true;
                artifactMoved = false;
                isDragging = true; // Global flag to prevent note creation
                clearTimeout(dragTimer);

                bringToFront(artifact);

                // FIX: Use ternary operator to safely get coordinates
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                initialX = clientX - artifact.offsetLeft;
                initialY = clientY - artifact.offsetTop;
                
                // Attach global listeners for drag and end events ONLY when starting a drag
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', dragEnd);
                document.addEventListener('touchmove', drag);
                document.addEventListener('touchend', dragEnd);
            }

            const drag = (e) => {
                if (!isLocalDragging) return;
                e.preventDefault(); 

                // FIX: Use ternary operator to safely get coordinates
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                currentX = clientX - initialX;
                currentY = clientY - initialY;

                artifact.style.left = `${currentX}px`;
                artifact.style.top = `${currentY}px`;
                artifactMoved = true;
            }

            const dragEnd = () => {
                if (!isLocalDragging) return;

                isLocalDragging = false;
                dragTimer = setTimeout(() => { isDragging = false; }, 50);

                if (artifactMoved) {
                    // Save new position
                    saveArtifact(id, { x: currentX, y: currentY });
                }

                // Update offsets for the next drag start
                xOffset = currentX; 
                yOffset = currentY;
                
                // Detach global listeners immediately after drag ends
                document.removeEventListener('mousemove', drag);
                document.removeEventListener('mouseup', dragEnd);
                document.removeEventListener('touchmove', drag);
                document.removeEventListener('touchend', dragEnd);
            }

            // Attach drag start events to the artifact body
            artifact.addEventListener('mousedown', dragStart);
            artifact.addEventListener('touchstart', dragStart);

            // Note: The artifact is appended to the container in renderNotes or handlePaste.
        }

        /**
         * Handles the click on the board background to create a new text note.
         */
        function handleBoardClick(e) {
            // Do not create a new note if currently dragging or resizing or clicking on an artifact/header
            if (isDragging || isResizing || e.target.closest('header')) {
                return;
            }
            
            // Check if click originated from background
            if (e.target.closest('.artifact')) {
                return;
            }

            const x = e.clientX;
            const y = e.clientY;

            highestZIndex++;
            const newId = generateUniqueId(); 

            // Create new note data object using defaults and new position/z-index
            const newNoteData = {
                ...DEFAULT_NOTE_PROPS,
                x: x - (MIN_SIZE_NOTE / 2), // Center the note roughly on the click point
                y: y,
                z: highestZIndex,
            };

            // Save to in-memory state and localStorage
            notes[newId] = newNoteData;
            saveArtifact(newId, newNoteData); // Use the unified save function
            
            // Create and add to DOM immediately
            renderNotes();
        }
        
        // Start the application by loading existing notes from local storage
        window.onload = loadNotes;
    </script>
</body>
</html>
