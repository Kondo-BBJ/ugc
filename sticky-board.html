<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Your Local Sticky Board</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
            min-height: 100vh;
            cursor: pointer;
        }
        .note {
            box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.3);
            min-width: 220px;
            min-height: 200px;
            padding: 5px;
            position: absolute;
            cursor: grab;
            user-select: none;
            transition: box-shadow 0.1s;
            border-radius: 0.5rem;
            display: flex;
            flex-direction: column;
        }
        .note:active {
            box-shadow: 8px 8px 20px rgba(0, 0, 0, 0.4);
            transform: rotate(1deg);
            cursor: grabbing;
        }
        .note-content-area {
            flex-grow: 1;
            padding: 15px 5px 5px 5px;
            display: flex;
            flex-direction: column;
        }
        .note textarea {
            flex-grow: 1;
            resize: none;
            border: none;
            background: transparent;
            width: 100%;
            height: 100%;
            padding: 0;
            outline: none;
            color: #374151;
            cursor: text;
            line-height: 1.4;
            user-select: text !important;
        }

        .note-text-align-center { text-align: center; }
        .note-text-align-right { text-align: right; }
        
        .note-container {
            position: relative;
            min-height: 80vh;
        }
        .delete-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 20px;
            height: 20px;
            background-color: rgba(255, 255, 255, 0.5);
            color: #ef4444;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.75rem;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
            opacity: 0.8;
            transition: opacity 0.15s, background-color 0.15s;
            z-index: 10;
        }
        .delete-btn:hover {
            opacity: 1;
            background-color: #f87171;
            color: white;
        }
        .header {
            padding: 24px 24px 16px 24px;
        }

        /* Resizing Handle Styles */
        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 15px;
            height: 15px;
            cursor: nwse-resize;
            z-index: 20;
            border-bottom: 15px solid rgba(0, 0, 0, 0.15);
            border-left: 15px solid transparent;
            border-radius: 0 0 0.5rem 0;
            opacity: 0.8;
            transition: opacity 0.15s;
        }
        .resize-handle:hover {
            opacity: 1;
        }

        /* Toolbar Styling */
        .toolbar {
            border-top: 1px solid rgba(209, 213, 219, 0.5);
            padding-top: 5px;
            padding-bottom: 2px;
            margin-top: 5px;
        }
        .toolbar-btn {
            padding: 2px 5px;
            margin: 0 2px;
            border-radius: 4px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.1s;
            line-height: 1;
        }
        .toolbar-btn:hover {
            background-color: rgba(0, 0, 0, 0.1);
        }
        .toolbar-btn.active {
            background-color: rgba(0, 0, 0, 0.2);
            font-weight: 700;
        }
        .color-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.1s;
        }
        .color-dot.active {
            border-color: #374151;
        }
    </style>
</head>
<body id="stickyBoard">

    <header class="header bg-transparent text-center">
        <h1 class="text-4xl font-extrabold text-gray-800 mb-2">Your Local Sticky Board</h1>
        <p class="text-lg text-gray-600 flex items-center justify-center">
            <svg class="w-5 h-5 mr-2 text-indigo-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg>
            Click the background to create a note. Drag the top margin of the note body to move, and the corner to resize.
        </p>
    </header>

    <div id="notesContainer" class="note-container w-full">
        </div>

    <script>
        // Global State & Constants
        let highestZIndex = 1;
        let isDragging = false;
        let isResizing = false;
        let dragTimer = 0; 
        
        let notes = {}; 
        
        const MIN_SIZE = 220; 

        const COLORS = [
            { name: 'yellow', class: 'bg-yellow-200' }, 
            { name: 'blue', class: 'bg-blue-200' },    
            { name: 'green', class: 'bg-green-200' },   
            { name: 'pink', class: 'bg-pink-200' }     
        ];
        
        const FONT_SIZES = [
            { label: 'S', value: 'sm', class: 'text-sm' },
            { label: 'M', value: 'md', class: 'text-base' },
            { label: 'L', value: 'lg', class: 'text-lg' }
        ];

        const DEFAULT_NOTE_PROPS = {
            content: '',
            x: 50,
            y: 100,
            z: 1,
            width: MIN_SIZE,
            height: MIN_SIZE,
            color: 'yellow',
            fontSize: 'md', 
            fontWeight: 'normal',
            fontStyle: 'normal',
            textAlign: 'left' 
        };

        let CONTAINER_OFFSET_TOP = 0; 


        /**
         * Generates a unique ID.
         */
        function generateUniqueId() {
            return 'note-' + crypto.randomUUID();
        }

        /**
         * Calculates and stores the container vertical offset.
         */
        function calculateOffsets() {
            const containerEl = document.getElementById('notesContainer');
            if (containerEl) {
                CONTAINER_OFFSET_TOP = containerEl.getBoundingClientRect().top + window.scrollY;
            }
        }

        // --- LOCAL STORAGE FUNCTIONS ---
        
        /**
         * Saves the current in-memory notes object to localStorage.
         */
        function saveNotes() {
            localStorage.setItem('stickyNotesData', JSON.stringify(notes));
        }

        /**
         * Loads notes from localStorage.
         */
        function loadNotes() {
            calculateOffsets(); 
            window.addEventListener('resize', calculateOffsets);
            
            const stored = localStorage.getItem('stickyNotesData');
            if (stored) {
                try {
                    notes = JSON.parse(stored);
                    
                    Object.values(notes).forEach(note => {
                        Object.keys(DEFAULT_NOTE_PROPS).forEach(key => {
                            if (note[key] === undefined) {
                                note[key] = DEFAULT_NOTE_PROPS[key];
                            }
                        });

                        if (note.z > highestZIndex) {
                            highestZIndex = note.z;
                        }
                    });
                } catch (e) {
                    console.error("Error parsing stored notes from localStorage. Starting with empty board.", e);
                    notes = {};
                }
            }
            renderNotes();
            document.body.addEventListener('click', handleBoardClick);
        }
        
        /**
         * Renders all notes from the 'notes' object to the DOM.
         */
        function renderNotes() {
            const container = document.getElementById('notesContainer');
            container.innerHTML = ''; 
            
            const sortedNotes = Object.entries(notes).sort(([, a], [, b]) => a.z - b.z);
            
            sortedNotes.forEach(([id, data]) => {
                createNoteElement(id, data.content, data.x, data.y, data.z, data.width, data.height);
            });
        }

        // --- LOCAL CRUD OPERATIONS ---
        
        /**
         * Updates the in-memory note object and saves to localStorage.
         */
        function saveNote(id, data) {
            if (!notes[id]) {
                notes[id] = { ...DEFAULT_NOTE_PROPS, z: highestZIndex };
            }
            notes[id] = { ...notes[id], ...data };
            saveNotes();
        }

        /**
         * Deletes a sticky note from the in-memory object and localStorage.
         */
        function deleteNote(id) {
            delete notes[id];
            
            const noteEl = document.getElementById(id);
            if (noteEl) {
                noteEl.remove();
            }
            
            saveNotes();
        }


        // --- DOM MANIPULATION & INTERACTION ---

        /**
         * Applies styling based on the note data object.
         */
        function applyNoteStyles(noteEl, data) {
            const currentNote = notes[noteEl.id];
            if (!currentNote) return;

            // 1. Color
            const colorClass = COLORS.find(c => c.name === data.color)?.class || COLORS[0].class;
            noteEl.classList.remove(...COLORS.map(c => c.class));
            noteEl.classList.add(colorClass);

            // 2. Font Styles (Applied to textarea)
            const textarea = noteEl.querySelector('textarea');
            if (textarea) {
                textarea.classList.remove('font-bold', 'italic', 'font-normal', 'not-italic');
                textarea.classList.remove(...FONT_SIZES.map(s => s.class));
                
                textarea.classList.remove('note-text-align-center', 'note-text-align-right'); 
                
                textarea.classList.add(data.fontWeight === 'bold' ? 'font-bold' : 'font-normal');
                textarea.classList.add(data.fontStyle === 'italic' ? 'italic' : 'not-italic');
                
                const fontSizeClass = FONT_SIZES.find(s => s.value === data.fontSize)?.class || FONT_SIZES[1].class;
                textarea.classList.add(fontSizeClass);

                if (data.textAlign === 'center') {
                    textarea.classList.add('note-text-align-center');
                } else if (data.textAlign === 'right') {
                    textarea.classList.add('note-text-align-right');
                }
            }

            // 3. Toolbar Active States (Applied to controls)
            const toolbar = noteEl.querySelector('.toolbar');
            if (toolbar) {
                toolbar.querySelectorAll('.color-dot').forEach(dot => {
                    dot.classList.remove('active');
                    if (dot.getAttribute('data-color') === data.color) {
                        dot.classList.add('active');
                    }
                });

                toolbar.querySelectorAll('.size-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.getAttribute('data-size') === data.fontSize) {
                        btn.classList.add('active');
                    }
                });

                toolbar.querySelector('[data-style="bold"]').classList.toggle('active', data.fontWeight === 'bold');
                toolbar.querySelector('[data-style="italic"]').classList.toggle('active', data.fontStyle === 'italic');
            }
        }

        /**
         * Creates the configuration toolbar for a sticky note.
         */
        function createToolbar(noteId) {
            // FIX: Changed justify-between to justify-start and added space-x-4
            const toolbar = document.createElement('div');
            toolbar.className = 'toolbar flex items-center justify-start space-x-4 p-1 mt-1'; 

            // --- 1. Left Group: Color Selection ---
            const leftGroup = document.createElement('div');
            leftGroup.className = 'flex items-center space-x-1'; 

            // Color Selection
            const colorGroup = document.createElement('div');
            colorGroup.className = 'flex space-x-1';
            
            COLORS.forEach(color => {
                const dot = document.createElement('div');
                dot.className = `color-dot ${color.class}`;
                dot.setAttribute('data-color', color.name);
                dot.title = `Change color to ${color.name}`;

                dot.addEventListener('click', (e) => {
                    e.stopPropagation();
                    saveNote(noteId, { color: color.name });
                    applyNoteStyles(document.getElementById(noteId), notes[noteId]);
                });
                colorGroup.appendChild(dot);
            });
            leftGroup.appendChild(colorGroup);
            
            toolbar.appendChild(leftGroup);


            // --- 2. Right Group: Font Style and Size Controls ---
            const rightGroup = document.createElement('div');
            rightGroup.className = 'flex items-center space-x-1 text-xs text-gray-700';

            // Bold Button
            const boldBtn = document.createElement('span');
            boldBtn.className = 'toolbar-btn font-extrabold select-none';
            boldBtn.textContent = 'B';
            boldBtn.setAttribute('data-style', 'bold');
            boldBtn.title = 'Toggle Bold';

            boldBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const currentWeight = notes[noteId].fontWeight;
                const newWeight = currentWeight === 'bold' ? 'normal' : 'bold';
                saveNote(noteId, { fontWeight: newWeight });
                applyNoteStyles(document.getElementById(noteId), notes[noteId]);
            });

            // Italic Button
            const italicBtn = document.createElement('span');
            italicBtn.className = 'toolbar-btn italic select-none';
            italicBtn.textContent = 'I';
            italicBtn.setAttribute('data-style', 'italic');
            italicBtn.title = 'Toggle Italic';
            
            italicBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const currentStyle = notes[noteId].fontStyle;
                const newStyle = currentStyle === 'italic' ? 'normal' : 'italic';
                saveNote(noteId, { fontStyle: newStyle });
                applyNoteStyles(document.getElementById(noteId), notes[noteId]);
            });
            
            rightGroup.appendChild(boldBtn);
            rightGroup.appendChild(italicBtn);
            
            // Font Size Buttons
            FONT_SIZES.forEach(size => {
                const sizeBtn = document.createElement('span');
                sizeBtn.className = `toolbar-btn size-btn select-none`;
                sizeBtn.textContent = size.label;
                sizeBtn.setAttribute('data-size', size.value);
                sizeBtn.title = `Font Size ${size.label}`;

                sizeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    saveNote(noteId, { fontSize: size.value });
                    applyNoteStyles(document.getElementById(noteId), notes[noteId]);
                });
                rightGroup.appendChild(sizeBtn);
            });

            toolbar.appendChild(rightGroup);

            return toolbar;
        }


        /**
         * Creates a draggable and resizable sticky note element.
         */
        function createNoteElement(id, content, x, y, z, width, height) {
            const container = document.getElementById('notesContainer');
            const data = notes[id];

            const note = document.createElement('div');
            note.id = id; 
            note.className = 'note rounded-lg shadow-lg hover:shadow-xl transition-shadow';
            note.setAttribute('data-id', id);
            note.style.left = `${x}px`;
            note.style.top = `${y}px`;
            note.style.zIndex = z;
            note.style.width = `${width}px`;
            note.style.height = `${height}px`;

            highestZIndex = Math.max(highestZIndex, z);

            // 1. Content Area
            const contentArea = document.createElement('div');
            contentArea.className = 'note-content-area';
            note.appendChild(contentArea);
            
            // 2. Textarea
            const textarea = document.createElement('textarea');
            textarea.value = content;
            textarea.placeholder = 'Write your thoughts...';
            textarea.maxLength = 1000; 
            contentArea.appendChild(textarea);
            
            // 3. Toolbar
            const toolbar = createToolbar(id);
            note.appendChild(toolbar); 


            // Textarea input listener (saves content on change)
            textarea.addEventListener('input', (e) => {
                e.stopPropagation();
                clearTimeout(textarea.saveTimeout);
                textarea.saveTimeout = setTimeout(() => {
                    saveNote(id, { content: textarea.value });
                }, 500);
            });

            // Focus listener (brings note to front)
            textarea.addEventListener('focus', (e) => {
                e.stopPropagation(); 
                bringToFront(note);
            });


            // 4. Delete Button
            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'delete-btn';
            deleteBtn.textContent = 'X';
            deleteBtn.title = 'Delete Note';
            deleteBtn.addEventListener('mousedown', (e) => { 
                e.stopPropagation(); 
                deleteNote(id);
            });
            note.appendChild(deleteBtn);
            
            // 5. Resizing Handle
            const resizeHandle = document.createElement('div');
            resizeHandle.className = 'resize-handle';
            
            // --- RESIZING LOGIC ---
            let initialMouseX, initialMouseY, initialWidth, initialHeight;
            let currentWidth, currentHeight;

            const resizeStart = (e) => {
                e.stopPropagation();
                e.preventDefault(); 

                isResizing = true;
                bringToFront(note);

                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;

                initialMouseX = clientX;
                initialMouseY = clientY;
                
                initialWidth = note.offsetWidth;
                initialHeight = note.offsetHeight;
            }

            const resize = (e) => {
                if (!isResizing) return;
                e.preventDefault(); 

                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;

                const dx = clientX - initialMouseX;
                const dy = clientY - initialMouseY;

                currentWidth = Math.max(MIN_SIZE, initialWidth + dx);
                currentHeight = Math.max(MIN_SIZE, initialHeight + dy);

                note.style.width = `${currentWidth}px`;
                note.style.height = `${currentHeight}px`;
            }

            const resizeEnd = () => {
                if (!isResizing) return;

                isResizing = false;
                
                if (currentWidth && currentHeight) {
                    saveNote(id, { width: currentWidth, height: currentHeight });
                }
            }
            
            // Attach mouse events for resizing
            resizeHandle.addEventListener('mousedown', resizeStart);
            document.addEventListener('mouseup', resizeEnd);
            document.addEventListener('mousemove', resize);

            // Attach touch events for resizing
            resizeHandle.addEventListener('touchstart', resizeStart);
            document.addEventListener('touchend', resizeEnd);
            document.addEventListener('touchmove', resize);
            note.appendChild(resizeHandle);
            
            // --- DRAGGING LOGIC ---

            let isLocalDragging = false;
            let currentX, currentY, offsetX, offsetY, noteMoved = false;

            const dragStart = (e) => {
                if (isResizing) return; 
                e.stopPropagation();

                if (e.target.closest('.toolbar') || e.target.tagName === 'TEXTAREA' || e.target.classList.contains('delete-btn') || e.target.classList.contains('resize-handle')) {
                    return;
                }

                e.preventDefault(); 
                
                isLocalDragging = true;
                noteMoved = false;
                isDragging = true;
                clearTimeout(dragTimer);

                bringToFront(note);

                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                
                const noteRect = note.getBoundingClientRect();
                
                offsetX = clientX - noteRect.left;
                offsetY = clientY - noteRect.top;
            }

            const drag = (e) => {
                if (!isLocalDragging) return;
                e.preventDefault(); 

                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                
                currentX = clientX - offsetX;
                currentY = (clientY - offsetY) - CONTAINER_OFFSET_TOP;

                note.style.left = `${currentX}px`;
                note.style.top = `${currentY}px`;
                noteMoved = true;
            }

            const dragEnd = () => {
                if (!isLocalDragging) return;

                isLocalDragging = false;
                dragTimer = setTimeout(() => { isDragging = false; }, 50);

                if (noteMoved) {
                    saveNote(id, { x: currentX, y: currentY });
                }
            }

            // Attach drag events to the main note body
            note.addEventListener('mousedown', dragStart);
            document.addEventListener('mouseup', dragEnd);
            document.addEventListener('mousemove', drag);
            note.addEventListener('touchstart', dragStart);
            document.addEventListener('touchend', dragEnd);
            note.addEventListener('touchmove', drag);

            container.appendChild(note);

            applyNoteStyles(note, data);

            return note;
        }

        /**
         * Increases the Z-index of the given note element and saves it locally.
         */
        function bringToFront(noteEl) {
            highestZIndex++;
            noteEl.style.zIndex = highestZIndex;
            const noteId = noteEl.getAttribute('data-id');
            saveNote(noteId, { z: highestZIndex });
        }


        /**
         * Handles the click on the board background to create a new note.
         */
        function handleBoardClick(e) {
            if (isDragging || isResizing || e.target.closest('header')) {
                return;
            }
            
            if (e.target.closest('.note')) {
                return;
            }

            const x = e.clientX;
            const y = e.clientY;

            highestZIndex++;
            const newId = generateUniqueId(); 

            const relativeY = y - CONTAINER_OFFSET_TOP;
            
            const safeY = Math.max(0, relativeY);

            const newNoteData = {
                ...DEFAULT_NOTE_PROPS,
                x: x - (MIN_SIZE / 2), 
                y: safeY,
                z: highestZIndex,
            };

            notes[newId] = newNoteData;
            saveNotes();
            
            createNoteElement(newId, newNoteData.content, newNoteData.x, newNoteData.y, newNoteData.z, newNoteData.width, newNoteData.height);
        }
        
        window.onload = loadNotes;
    </script>
</body>
</html>
